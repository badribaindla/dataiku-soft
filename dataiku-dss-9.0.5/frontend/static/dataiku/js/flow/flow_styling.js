(function(){
'use strict';

const app = angular.module('dataiku.flow.graph');


/* We get a first SVG flow generated by graphviz in the backend,
 * frontend post-processing is done here
 */


app.service('ProjectFlowGraphStyling', function($filter, FlowGraph, CachedAPICalls, LoggerProvider, TimingService, $sanitize, DataikuAPI, $rootScope, $q, objectTypeFromNodeFlowType, $state, $compile) {

const SIZE = 100;

const logger = LoggerProvider.getLogger('flow');

let flowIconset;
 CachedAPICalls.flowIcons.success(function(data) {
    flowIconset = data;
});

const formatters = {
    'RECIPE': restyleRecipeNode,
    'LOCAL_DATASET': restyleDatasetNode(true),
    'FOREIGN_DATASET': restyleDatasetNode(false),
    'LOCAL_SAVEDMODEL': restyleModelNode(true),
    'FOREIGN_SAVEDMODEL': restyleModelNode(false),
    'LOCAL_MODELEVALUATIONSTORE': restyleEvaluationStoreNode(true),
    'FOREIGN_MODELEVALUATIONSTORE': restyleEvaluationStoreNode(false),
    'LOCAL_MANAGED_FOLDER': restyleFolderNode(true),
    'FOREIGN_MANAGED_FOLDER': restyleFolderNode(false),
    'LOCAL_STREAMING_ENDPOINT': restyleStreamingEndpointNode(true),
    'FOREIGN_STREAMING_ENDPOINT': restyleStreamingEndpointNode(false)
};

this.restyleGraph = TimingService.wrapInTimePrinter("ProjectFlowGraphStyling::restyleGraph", function(svg, $scope) {
    const zones = svg.find('.zone_cluster');
    if (zones) {
        for (let i = 0; i < zones.length; i++) {
            const zone = zones[i];
            try {
                restyleZone(svg, zone, $scope);
            } catch (e) {
                logger.error("Failed to restyle flow zone: ", e);
            }
        }
    }
    svg.find(".zone_label_remove").remove();
    svg.find('text').remove();
    svg.find('title').remove();

    const nodes = $('.node:not(.zone)', svg);

    if (nodes) {
        for (let i = 0; i<nodes.length; i++) {
            const g = nodes[i];
            try {
                restyleNode(g);
            } catch (e) {
                logger.error("Failed to restyle flow node: ", e);
            }
        }
    }
    svg.find('.node.zone>svg g polygon').remove();
});


function drawInformationSticker(svg, coords) {
    svg.appendChild(makeSVG('ellipse', {
        class: 'flow-information-sticker__background',
        cx: coords.cx,
        cy: coords.cy,
        rx: coords.rx,
        ry: coords.ry
    }));

    svg.appendChild(makeForeignObject({
        x: coords.indicatorX,
        y: coords.indicatorY,
        width: 20,
        height: 20,
        class: 'flow-information-sticker__indicator',
    }, $(`<span size="32" class="icon-info-sign">`)));
}

function drawDiscussionSticker(svg, discussionCount, has_unread_discussions, coords, offset, indicatorOffset = {x: 0, y: 0}) {
    svg.appendChild(makeSVG('ellipse', {
        class: 'flow-discussions-sticker__background',
        cx: coords.cx - offset.x,
        cy: coords.cy - offset.y,
        rx: coords.rx,
        ry: coords.ry
    }));

    svg.appendChild(makeForeignObject({
        x: coords.indicatorX - offset.x - indicatorOffset.x,
        y: coords.indicatorY - offset.y - indicatorOffset.y,
        width: 20,
        height: 20,
        class: 'flow-discussions-sticker__indicator' + ((has_unread_discussions) ? ' flow-discussions-sticker__indicator--unread' : ''),
    }, $(`<span size="32" class="icon-dku-discussions">`)));
    
    svg.appendChild(makeForeignObject({
        x: coords.contentX - offset.x,
        y: coords.contentY - offset.y,
        width: 40,
        height: 20,
        class: 'flow-discussions-sticker__content',
    }, $(`<span>` + (discussionCount > 9 ? '9+' : discussionCount) + `</span>`)));
}

function hasUnreadDiscussion(flowNode) {
    return (($rootScope.discussionsUnreadStatus || {}).unreadFullIds || []).find(discuId => (flowNode.discussionsFullIds || []).includes(discuId));
}

function restyleNode(g) {
    const nodeType = $(g).attr('data-type');
    if (formatters[nodeType]) {
        formatters[nodeType](g);
    }
}

function restyleZone(svg, zone_cluster, $scope) {
    const jZone_cluster = $(zone_cluster);
    const cluster_polygon = jZone_cluster.find('>polygon');
    const text = jZone_cluster.find(">text");
    const id = zone_cluster.id.split("_").splice(2).join('');
    const zone = svg.find(`.zone[id='zone_${id}']`);
    const zone_polygon = zone.find('>polygon');
    // Calculate difference between zone top and cluster top (Gives us the height for the text)

    if (zone_polygon && cluster_polygon) {
        const zone_coords = polygonToRectData(zone_polygon);
        const cluster_coords = polygonToRectData(cluster_polygon);
        const zoneNode = FlowGraph.node(`zone_${id}`);
        const collapseIcon = zoneNode.customData.isCollapsed ? "icon-resize-full" : "icon-resize-small";
        let height = (zone_coords.y - cluster_coords.y) * 2;
        if (!height > 0) {
            logger.warn("Calculated height is not a valid number, default to 44");
            height = 44;
        }
        const foreignObject = makeForeignObject({
            x: cluster_coords.x,
            y: cluster_coords.y,
            width: zone_coords.width,
            height,
            class: 'zone_header'
        }, $(`<div><p>${$sanitize(text.text())}</p><i ng-click="toggleZoneCollapse([{id:'${$sanitize(id)}'}])" class="${collapseIcon} cursor-pointer" id="collapse-button-zone-${$sanitize(id)}"/><i ng-click="zoomOnZone('${$sanitize(id)}')" class="icon-DKU_expand cursor-pointer"/></div>`));
        const color = d3.rgb(zoneNode.customData.color);
        const zoneTitleColor = (color.r*0.299 + color.g*0.587 + color.b*0.114) >= 128 ? "#000" : "#FFF";
        foreignObject.style = `background-color: ${color}; color: ${zoneTitleColor}; border-bottom: none;`;
        zone_cluster.appendChild(makeSVG('g', {
            class: 'tool-simple-zone',
            transform: `translate(${cluster_coords.x + cluster_coords.width}, ${cluster_coords.y + cluster_coords.height})`,
            'data-height': 0
        }));
        zone_cluster.appendChild(foreignObject);
        $compile(foreignObject)($scope);
        zone_polygon.remove();
    }

    $(zone_cluster)[0].setAttribute("data-zone-title", $sanitize(text[0].textContent));
    $(zone_cluster)[0].setAttribute("data-id", "zone_" + $sanitize(id));
}

function restyleDatasetNode(local) {
    // Note that differentiation local/foreign is made with CSS
    return function (g) {
        const nodeId = $(g).attr('data-id');
        const nodeZoneId = $(g).attr('data-zone-id');
        const dataset = FlowGraph.node(nodeId);

        const dotPolygon = $(g).find("polygon");
        if (dotPolygon.length) {
            const coords = polygonToRectData(dotPolygon);

            let clazz = 'newG';
            if (dataset.neverBuilt) {
                clazz += ' never-built-computable';
            }
            const newG = makeSVG('g', {class: clazz, transform: `translate(${coords.x} ${coords.y})`});
            d3.select(newG).classed("bzicon", true);

            const othersZones = FlowGraph.nodeSharedBetweenZones(dataset);
            const isExported = othersZones && !othersZones.has(nodeZoneId);
            const isImported = othersZones && othersZones.has(nodeZoneId);
            const margin = isExported && othersZones.size > 0 ? 4 : 0;

            if (dataset.partitioned) {
                newG.appendChild(makeSVG('rect', {
                    x: -10,
                    y: -10,
                    width: coords.width,
                    height: coords.height,
                    class: 'fill dataset-rectangle partitioning-indicator' + (isImported ? ' dataset-zone-imported' : '')
                }));

                newG.appendChild(makeSVG('rect', {
                    x: -5,
                    y: -5,
                    width: coords.width,
                    height: coords.height,
                    class: 'fill dataset-rectangle partitioning-indicator' + (isImported ? ' dataset-zone-imported' : '')
                }));
            }


            if (isExported) {
                newG.appendChild(makeSVG('rect', {
                    x: 0,
                    y: 0,
                    width: coords.width,
                    height: coords.height,
                    class: 'fill dataset-zone-exported'
                }));
            }
            newG.appendChild(makeSVG('rect', {
                x: margin,
                y: margin,
                width: coords.width - (margin*2),
                height: coords.height - (margin*2),
                class: 'fill dataset-rectangle main-dataset-rectangle' + (isImported ? ' dataset-zone-imported' : '')
            }));

            newG.appendChild(makeSVG('g', {
                class: 'tool-simple-zone',
                transform: `translate(${coords.width}, 0)`,
                'data-height': '72'
            }));

            newG.appendChild(makeForeignObject({
                x: -30,
                y: coords.height * 1.07,
                width: coords.width + 60,
                height: 45,
                class: 'nodelabel-wrapper'
            }, $('<div><span>' + $sanitize(dataset.description.replace(/([-_])/g, '$1\u200b')) + '</span></div>')));

            const icon = $filter("datasetTypeToIcon")(dataset.datasetType);
            newG.appendChild(makeForeignObject({
                x: 15,
                y: 16,
                width: 42,
                height: 42,
                class: 'nodeicon' + (isImported ? 'dataset-imported' : '')
            }, $(`<div style="text-align: center"><i class="${icon}" /></div>`)));

            newG.appendChild(makeSVG('rect', {
                class: 'selection-outline',
                x: 0,
                y: 0,
                width: 72,
                height: 72
            }));

            newG.appendChild(makeForeignObject({
                x: 56,
                y: -15,
                width: 34,
                height: 34,
                class: 'node-totem'
            }, $(`<span size="32">`)));

            let offset = {x: 0, y: 0};

            // Information sticker
            // To display when the dataset has a short description
            if (angular.isDefined(dataset.shortDesc) && dataset.shortDesc.length > 0) {
                let coords = {
                    cx: 1,
                    cy: 67,
                    rx: 10,
                    ry: 10,
                    indicatorX: -9,
                    indicatorY: 57
                };

                drawInformationSticker(newG, coords);
                offset.y += 20;
            }

            // Discussion sticker
            // To display when the dataset has an unread discussion
            if (local && dataset.discussionsFullIds.length > 0) {

                let unread = hasUnreadDiscussion(dataset);
                let coords = {
                    cx: 0,
                    cy: 69.5,
                    rx: 10.5,
                    ry: 9,
                    indicatorX: -10,
                    indicatorY: 60,
                    contentX: -20,
                    contentY: 60
                };
                const isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
                drawDiscussionSticker(newG, dataset.discussionsFullIds.length, unread, coords, offset, {x: 0, y: isFirefox ? -2 : 0});

            }

            $(dotPolygon).replaceWith(newG);
        }
    }
}

function restyleModelNode(local) {
    return function(g) {
        const nodeId = $(g).attr('data-id');
        const nodeZoneId = $(g).attr('data-zone-id');
        const sm = FlowGraph.node(nodeId);

        const dotPolygon = $(g).find('polygon');
        if (dotPolygon.length) {
            $(g).find("text").remove();
            const coords = polygonToRectData(dotPolygon);
            const newG = makeSVG('g', {class: 'newG', transform: `translate(${coords.x} ${coords.y-coords.height})`});

            newG.appendChild(makeSVG('rect', {
                x: 0,
                y: 0,
                width: coords.width * 0.707,
                height: coords.height * 0.707,
                transform: `translate(${coords.width/2}) rotate(45)`,
                opacity: 0,
                class: 'fill'
            }));

            const othersZones = FlowGraph.nodeSharedBetweenZones(sm);
            const isExported = othersZones && !othersZones.has(nodeZoneId);
            const isImported = othersZones && othersZones.has(nodeZoneId);

            if (sm.partitioned) {
                /* Partition boxes */
                for (let offset of [-10, -5, 0]) {
                    newG.appendChild(makeSVG('rect', {
                        x: offset,
                        y: offset,
                        width: coords.width * 1.41421,
                        height: coords.height * 1.41421,
                        transform: `translate(${coords.width}) rotate(45)`,
                        class: 'fill node__rectangle--partitioned partitioning-indicator'
                    }));
                }

                /* White background for the rest of the icon */
                newG.appendChild(makeSVG('rect', {
                    x: 0,
                    y: 0,
                    width: coords.width * 1.41421,
                    height: coords.height * 1.41421,
                    transform: `translate(${coords.width}) rotate(45)`,
                    class: 'node__rectangle--blank'
                }));
            }

            if (isExported) {
                newG.appendChild(makeSVG('rect', {
                    x: 0,
                    y: 0,
                    width: coords.width * 1.41421,
                    height: coords.height * 1.41421,
                    transform: `translate(${coords.width}) rotate(45)`,
                    class: 'fill model-zone-exported'
                }));
            }

            const iconText = flowIconset.icons[sm.smType == "CLUSTERING" ? "model_clustering" : "model_regression"];
            const iconElt = d3.select($.parseXML(iconText)).select("svg").selectAll("path");
            const newG2 = makeSVG("g");
            iconElt[0].forEach(i => newG2.appendChild(i));
            d3.select(newG2).attr("transform", " scale(0.707, 0.707) translate(1, 1)")
            d3.select(newG2).classed("bzicon sm-icon" + (isImported ? ' model-zone-imported': isExported ? ' model-zone-exported' : ''), true);

            newG.appendChild(newG2);

            newG.appendChild(makeSVG('g', {
                class: 'tool-simple-zone',
                transform: `translate(${coords.width + 26}, 24)`,
                'data-height': coords.height
            }));

            if (!sm.description) {
                sm.description = "Saved model...";
            }

            newG.appendChild(makeSVG('rect', {
                class: 'selection-outline',
                x: 0,
                y: 0,
                width: coords.width * 1.41421,
                height: coords.height * 1.41421,
                transform: `translate(${coords.width})  rotate(45)`,
            }));

                // x: -coords.width*0.2071,
            newG.appendChild(makeForeignObject({
                x: -30,
                y: coords.height * 2.07,
                width: coords.width*2+60,
                height: 42,
                class: 'nodelabel-wrapper'
            }, $('<div><span>' + $sanitize(sm.description.replace(/([-_])/g, '$1\u200b')) + '</span></div>')));

            newG.appendChild(makeForeignObject({
                x: 45,
                y: -10,
                width: 32,
                height: 32,
                class: 'node-totem'
            }, $(`<span size="32">`)));

            let offset = {x: 0, y: 0};

            // Information sticker
            // To display when the sm has a short description
            if (angular.isDefined(sm.shortDesc) && sm.shortDesc.length > 0) {
                let coords = {
                    cx: 27,
                    cy: 63,
                    rx: 10,
                    ry: 10,
                    indicatorX: 17,
                    indicatorY: 53
                };

                drawInformationSticker(newG, coords);
                offset.x += 12;
                offset.y += 12;
            }

            // Discussion sticker
            // To display when the dataset has an unread discussion
            if (local && sm.discussionsFullIds.length > 0) {

                let unread = hasUnreadDiscussion(sm);
                let coords = {
                    cx: 24,
                    cy: 64.5,
                    rx: 10.5,
                    ry: 9,
                    indicatorX: 14,
                    indicatorY: 55,
                    contentX: 4,
                    contentY: 55
                };
                const isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
                drawDiscussionSticker(newG, sm.discussionsFullIds.length, unread, coords, offset, {x: 0, y: isFirefox ? -2 : 0});

            }

            $(dotPolygon).replaceWith(newG);
        }
    }
}

function restyleEvaluationStoreNode(local) {
    return function(g) {
        const nodeId = $(g).attr('data-id');
        const nodeZoneId = $(g).attr('data-zone-id');
        const mes = FlowGraph.node(nodeId);

        const dotPolygon = $(g).find('polygon');
        if (dotPolygon.length) {
            $(g).find("text").remove();
            const coords = polygonToRectData(dotPolygon);
            const newG = makeSVG('g', {class: 'newG', transform: `translate(${coords.x} ${coords.y-coords.height})`});

            newG.appendChild(makeSVG('rect', {
                x: 0,
                y: 0,
                width: coords.width * 0.707,
                height: coords.height * 0.707,
                transform: `translate(${coords.width/2}) rotate(45)`,
                opacity: 0,
                class: 'fill'
            }));

            const othersZones = FlowGraph.nodeSharedBetweenZones(mes);
            const isExported = othersZones && !othersZones.has(nodeZoneId);
            const isImported = othersZones && othersZones.has(nodeZoneId);

            if (mes.partitioned) {
                /* Partition boxes */
                for (let offset of [-10, -5, 0]) {
                    newG.appendChild(makeSVG('rect', {
                        x: offset,
                        y: offset,
                        width: coords.width * 1.41421,
                        height: coords.height * 1.41421,
                        transform: `translate(${coords.width}) rotate(45)`,
                        class: 'fill node__rectangle--partitioned partitioning-indicator'
                    }));
                }

                /* White background for the rest of the icon */
                newG.appendChild(makeSVG('rect', {
                    x: 0,
                    y: 0,
                    width: coords.width * 1.41421,
                    height: coords.height * 1.41421,
                    transform: `translate(${coords.width}) rotate(45)`
                }));
            } else {
                newG.appendChild(makeSVG('rect', {
                    x: 0,
                    y: 0,
                    width: coords.width * 1.41421,
                    height: coords.height * 1.41421,
                    transform: `translate(${coords.width}) rotate(45)`
                }));
            }

            if (isExported) {
                newG.appendChild(makeSVG('rect', {
                    x: 0,
                    y: 0,
                    width: coords.width * 1.41421,
                    height: coords.height * 1.41421,
                    transform: `translate(${coords.width}) rotate(45)`,
                    class: 'fill evaluation-store-zone-exported'
                }));
            }

            const icon = 'icon-model-evaluation-store';
            newG.appendChild(makeForeignObject({
                x: 15,
                y: 16,
                width: 42,
                height: 42,
                class: 'nodeicon' + (isImported ? ' evaluation-store-zone-imported': isExported ? ' evaluation-store-zone-exported' : '')
            }, $(`<div style="text-align: center"><i class="${icon}" /></div>`)));

            newG.appendChild(makeSVG('g', {
                class: 'tool-simple-zone',
                transform: `translate(${coords.width + 26}, 24)`,
                'data-height': coords.height
            }));

            if (!mes.description) {
                mes.description = "Model evaluation store...";
            }

            newG.appendChild(makeSVG('rect', {
                class: 'selection-outline',
                x: 0,
                y: 0,
                width: coords.width * 1.41421,
                height: coords.height * 1.41421,
                transform: `translate(${coords.width})  rotate(45)`,
            }));

                // x: -coords.width*0.2071,
            newG.appendChild(makeForeignObject({
                x: -30,
                y: coords.height * 2.07,
                width: coords.width*2+60,
                height: 42,
                class: 'nodelabel-wrapper'
            }, $('<div><span>' + $sanitize(mes.description.replace(/([-_])/g, '$1\u200b')) + '</span></div>')));

            newG.appendChild(makeForeignObject({
                x: 45,
                y: -10,
                width: 32,
                height: 32,
                class: 'node-totem'
            }, $(`<span size="32">`)));

            let offset = {x: 0, y: 0};

            // Information sticker
            // To display when the mes has a short description
            if (angular.isDefined(mes.shortDesc) && mes.shortDesc.length > 0) {
                let coords = {
                    cx: 27,
                    cy: 63,
                    rx: 10,
                    ry: 10,
                    indicatorX: 17,
                    indicatorY: 53
                };

                drawInformationSticker(newG, coords);
                offset.x += 12;
                offset.y += 12;
            }

            // Discussion sticker
            // To display when the dataset has an unread discussion
            if (local && mes.discussionsFullIds.length > 0) {

                let unread = hasUnreadDiscussion(mes);
                let coords = {
                    cx: 24,
                    cy: 64.5,
                    rx: 10.5,
                    ry: 9,
                    indicatorX: 14,
                    indicatorY: 55,
                    contentX: 4,
                    contentY: 55
                };
                const isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
                drawDiscussionSticker(newG, mes.discussionsFullIds.length, unread, coords, offset, {x: 0, y: isFirefox ? -2 : 0});

            }

            $(dotPolygon).replaceWith(newG);
        }
    }
}

function restyleFolderNode(local) {
    return function(g) {
        const nodeId = $(g).attr('data-id');
        const nodeZoneId = $(g).attr('data-zone-id');
        const folder = FlowGraph.node(nodeId);

        const dotPolygon = $(g).find('polygon');
        if (dotPolygon.length) {
            const coords = polygonToRectData(dotPolygon);

            const newG = makeSVG('g', {class: 'newG', transform: `translate(${coords.x} ${coords.y})`});

            const othersZones = FlowGraph.nodeSharedBetweenZones(folder);
            const isExported = othersZones && !othersZones.has(nodeZoneId);
            const isImported = othersZones && othersZones.has(nodeZoneId);

            $(g).find("text").remove();

            const iconText = flowIconset.icons["folder"];
            let iconElt = d3.select($.parseXML(iconText)).select("svg").select("g")
            iconElt.attr("transform", " scale(0.57, 0.57) ");
            iconElt.classed("bzicon" + (isImported ? " folder-zone-imported" : ''), true);

            newG.appendChild(iconElt[0][0]);

            newG.appendChild(makeSVG('g', {
                class: 'tool-simple-zone',
                transform: `translate(${coords.width}, 0)`,
                'data-height': coords.height
            }));

            if (!folder.description) {
                folder.description = "Managed folder";
            }
            newG.appendChild(makeForeignObject({
                x: -30,
                y: coords.height * 1.01,
                width: coords.width + 60,
                height: 42,
                class: 'nodelabel-wrapper'
            }, $('<div><span>' + $sanitize(folder.description.replace(/([-_])/g, '$1\u200b')) + '</span></div>')));

            // Invisible rect to capture mouse events, else
            // the holes in the icon don't capture the mouse
            newG.appendChild(makeSVG('rect', {
                x: 0,
                y: 0,
                width: coords.width,
                height: coords.height,
                opacity: 0
            }));

            newG.appendChild(makeForeignObject({
                x: 48,
                y: -13,
                width: 32,
                height: 32,
                class: 'node-totem'
            }, $(`<span size="32">`)));

            let offset = {x: 0, y: 0};

            // Information sticker
            // To display when the folder has a short description
            if (angular.isDefined(folder.shortDesc) && folder.shortDesc.length > 0) {
                let coords = {
                    cx: 1,
                    cy: 55,
                    rx: 10,
                    ry: 10,
                    indicatorX: -9,
                    indicatorY: 45
                };

                drawInformationSticker(newG, coords);
                offset.y += 13;
            }

            // Discussion sticker
            // To display when the dataset has an unread discussion
            if (local && folder.discussionsFullIds.length > 0) {

                let unread = hasUnreadDiscussion(folder);
                let coords = {
                    cx: 0,
                    cy: 51.5,
                    rx: 10.5,
                    ry: 9,
                    indicatorX: -10,
                    indicatorY: 42,
                    contentX: -20,
                    contentY: 42
                };
                const isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
                drawDiscussionSticker(newG, folder.discussionsFullIds.length, unread, coords, offset, {x: 0, y: isFirefox ? -2 : 0});

            }

            $(dotPolygon).replaceWith(newG);
        }
    };
}

function restyleStreamingEndpointNode(local) {
    return function(g) {
        const nodeId = $(g).attr('data-id');
        const sm = FlowGraph.node(nodeId);

        const streamingEndpoint = FlowGraph.node(nodeId);
        const dotPolygon = $(g).find('polygon');
        if (dotPolygon.length) {
            $(g).find("text").remove();
            const coords = polygonToRectData(dotPolygon);
            const newG = makeSVG('g', {class: 'newG bzicon', transform: `translate(${coords.x} ${coords.y})`});
            d3.select(newG).classed("bzicon", true);

            newG.appendChild(makeSVG('path', {
                d: "M0,0 L48,0 L64,29 L48,58 L0,58 Z",
                opacity: 1,
                class: 'fill'
            }));

            const icon = $filter("datasetTypeToIcon")(streamingEndpoint.streamingEndpointType);
            newG.appendChild(makeForeignObject({
                x: 8,
                y: 8,
                width: 42,
                height: 42,
                class: 'nodeicon'
            }, $(`<div style="text-align: center"><i class="${icon}" /></div>`)));
            
            newG.appendChild(makeSVG('g', {
                class: 'tool-simple-zone',
                transform: `translate(${coords.width + 26}, 24)`,
                'data-height': coords.height
            }));

            newG.appendChild(makeSVG('path', {
                class: 'selection-outline',
                d: "M-1,-1 L48.5,-1 L65,29 L48.5,59 L-1,59 Z"
            }));

                // x: -coords.width*0.2071,
            newG.appendChild(makeForeignObject({
                x: -30,
                y: coords.height * 1.2,
                width: coords.width + 60,
                height: 42,
                class: 'nodelabel-wrapper'
            }, $('<div><span>' + sm.name.replace(/([-_])/g, '$1\u200b') + '</span></div>')));

            newG.appendChild(makeForeignObject({
                x: 45,
                y: -10,
                width: 32,
                height: 32,
                class: 'node-totem'
            }, $(`<span size="32">`)));

            $(dotPolygon).replaceWith(newG);
        }
    }
}

function restyleRecipeNode(g) {
    const nodeId = $(g).attr('data-id');
    const recipe = FlowGraph.node(nodeId);

    const iconScale = 0.52

    const dotEllipse = $(g).find("ellipse");
    if (dotEllipse.length) {
        const coords = circleToRectData(dotEllipse);
        const newG = makeSVG('g', {class: 'newG', transform: `translate(${coords.x} ${coords.y}) scale(${iconScale}, ${iconScale})`});

        const iconText = flowIconset.icons[$filter("recipeFlowIcon")(recipe.recipeType)];
        d3.select(newG).classed("bzicon recipeicon-" + recipe.recipeType, true);

        if (recipe.recipeType.startsWith("CustomCode_") || recipe.recipeType.startsWith("App_")) {
            const colorClass = $filter("recipeTypeToColorClass")(recipe.recipeType);
            d3.select(newG).classed("universe-fill " + colorClass, true);
        }

        d3.select(g).attr("data-recipe-type", recipe.recipeType);

        let iconElt = d3.select($.parseXML(iconText)).select("svg").selectAll("g");
        // Some icons don't have a g ...
        if (iconElt.length == 0 || iconElt[0].length == 0) {
            iconElt = d3.select($.parseXML(iconText)).select("svg").selectAll("path");
        }
        if (iconElt.length == 0 || iconElt[0].length == 0) {
            iconElt = d3.select($.parseXML(iconText)).select("svg").selectAll("path");
        }
        try {
            $(dotEllipse).replaceWith(newG);
            iconElt[0].forEach(function(x){
                newG.appendChild(x);
            });
            // Invisible rect to capture mouse events, else
            // the holes in the icon don't capture the mouse
            newG.appendChild(makeSVG('rect', {
                x: 0,
                y: 0,
                width: coords.width / iconScale,
                height: coords.height / iconScale,
                opacity: 0
            }));

        } catch (e) {
            logger.error("Failed patch recipe icon", e)
        }

        // WARNING: this conflicts with graphviz layout: recipe names and other nodes can overlap.
        // newG.appendChild(makeForeignObject({
        //     x: -30,
        //     y: coords.height * 1.07,
        //     width: coords.width + 60,
        //     height: 45,
        //     class: 'nodelabel-wrapper',
        //     transform: `scale(${1/iconScale}, ${1/iconScale})`
        // }, $('<div><span>' + recipe.description.replace(/([-_])/g, '$1\u200b') + '</span></div>')));

        if (recipe.recipeType.startsWith("CustomCode_") || recipe.recipeType.startsWith("App_")){
            const icon = $filter("recipeTypeToIcon")(recipe.recipeType);
            newG.appendChild(makeForeignObject({
                x: 0,
                y: 0,
                width: SIZE,
                height: SIZE,
                class: 'nodeicon'
            }, $('<div class="recipe-custom-code-object"><i class="' + icon + '"></i></div>')));
        }

        newG.appendChild(makeSVG('g', {
            class: 'tool-simple-zone',
            transform: `translate(${SIZE}, 0) scale(${1/iconScale}, ${1/iconScale})`,
            'data-height': SIZE * iconScale
        }));

        newG.appendChild(makeSVG('circle', {
            class: 'selection-outline',
            r: 50*iconScale,
            cx: 50*iconScale,
            cy: 50*iconScale,
            transform: `scale(${1/iconScale}, ${1/iconScale})`,
        }));

        newG.appendChild(makeForeignObject({
            x: 30,
            y: -17,
            width: 32,
            height: 32,
            class: 'node-totem',
            transform: `scale(${1/iconScale}, ${1/iconScale})`
        }, $(`<span size="32">`)));

        let offset = {x: 0, y: 0};

        // Information sticker
        // To display when the recipe has a short description
        if (angular.isDefined(recipe.shortDesc) && recipe.shortDesc.length > 0) {
            let coords = {
                cx: 14,
                cy: 86,
                rx: 20,
                ry: 20,
                indicatorX: 0,
                indicatorY: 69
            };

            drawInformationSticker(newG, coords);
            offset.x += 12;
            offset.y += 26;
        }

        // Discussion sticker
        // To display when the dataset has an unread discussion
        if (recipe.discussionsFullIds.length > 0) {

            let unread = hasUnreadDiscussion(recipe);
            let coords = {
                cx: 8.5,
                cy: 84.5,
                rx: 19,
                ry: 17,
                indicatorX: -9,
                indicatorY: 69,
                contentX: -11,
                contentY: 74
            };
            drawDiscussionSticker(newG, recipe.discussionsFullIds.length, unread, coords, offset);

        }
    }
}
});


app.service('ProjectFlowGraphLayout', function(FlowGraph, LoggerProvider) {

    var logger = LoggerProvider.getLogger('flow');

    // This function takes isolated ("draft") computables
    // and move them to a container to put them next to the flow
    // Note that things are called datasets for historical reasons but they might be other things
    this.relayout = function(globalSvg) {
        const zones = $(globalSvg).find("svg");
        if (zones && zones.length > 0) {
            for (let i = 0; i < zones.length; i++) {
                this.relayoutSVG($(zones[i]), true);
            }
        } else {
            this.relayoutSVG(globalSvg, false);
        }
    };

    this.relayoutSVG = (svg, zones) => {
        const usedDatasets = makeSVG('g', { class: 'usedDatasets' });
        const inputDatasets = makeSVG('g', { class: 'inputDatasets' });
        const draftDatasets = makeSVG('g', { class: 'draftDatasets' });
        svg.find('g[class=graph]').append(usedDatasets);
        $(usedDatasets).append(inputDatasets);
        svg.find('g[class=graph]').append(draftDatasets);

        svg.find('g[data-type]').each(function (index, boxElement) {
            const nodeId = $(boxElement).data("id");
            const node = FlowGraph.node(nodeId);
            if(!node) {
                logger.warn('Graph node does not exist: ', nodeId)
                return;
            }
            // hidden stuff is related to implicit (not recipes) links like a dataset and its metric dataset for example
            if(!node.predecessors.length && !node.successors.length && !node.isHiddenLinkSource && !node.isHiddenLinkTarget) {
                draftDatasets.appendChild(boxElement);
            } else if(!node.predecessors.length && !node.isHiddenLinkTarget && !node.isHiddenLinkSource) {
                inputDatasets.appendChild(boxElement);
            } else {
                usedDatasets.appendChild(boxElement);
            }
        });

        // Relayout
        const hasChildNodes = usedDatasets.childNodes.length + inputDatasets.childNodes.length > 1;
        let datasetsPerColumns = Math.max(inputDatasets.childNodes.length, Math.floor(Math.sqrt(draftDatasets.childNodes.length)), 1);
        let gridWidth = 180;
        let gridHeight = 180;
        let columnHeight = gridHeight * datasetsPerColumns;
        if(inputDatasets.childNodes.length && !zones) {
            datasetsPerColumns = inputDatasets.childNodes.length;
            gridWidth = inputDatasets.childNodes[0].getBBox().width + 50;
            columnHeight = inputDatasets.getBBox().height;
            gridHeight = columnHeight / datasetsPerColumns;
        }
        let nbFullRows = Math.floor(draftDatasets.childNodes.length / datasetsPerColumns) ||Â 1;
        for(let index = 0; index < draftDatasets.childNodes.length; index++) {
            // full row
            let offset = 0;
            if (nbFullRows > 0 && index >= nbFullRows * datasetsPerColumns) {
                offset = (columnHeight - gridHeight * (draftDatasets.childNodes.length % datasetsPerColumns))/2;
            }
            let dx = Math.floor(index / datasetsPerColumns) * gridWidth + 20;
            let dy = offset + index % datasetsPerColumns * gridHeight + 50;
            $(draftDatasets).children().eq(index).find('g').first().attr('transform', `translate(${dx}  ${dy})`);
        }

        //  move draftDatasets out of the way
        setTimeout(function() {
            let usedDatasetsBB = usedDatasets.getBBox();
            let draftDatasetsBB = draftDatasets.getBBox();
            let translateX = usedDatasetsBB.x - draftDatasetsBB.x - draftDatasetsBB.width - 200;
            let translateY = usedDatasetsBB.y - draftDatasetsBB.y;
            if (!zones) {
                draftDatasets.setAttribute('transform', 'translate(' + translateX + ' ' + translateY + ')');
            } else {
                let translateGraphY = hasChildNodes && draftDatasets.childNodes.length ? -usedDatasetsBB.y + 32 : hasChildNodes ? -usedDatasetsBB.y : -draftDatasetsBB.y;
                svg.find('g[class=graph]')[0].setAttribute('transform', 'translate(32,' + translateGraphY + ')');
            }
        });
    }
});


app.service('InterProjectGraphLayout', function(FlowGraph) {
    // Similar to project flow, this function takes isolated ("standalone") projects
    // and move them to a container to put them below the graph of connected (by exposed elements) projects
    this.relayout = function(svg) {
        let connectedProjects = makeSVG('g', { class: 'connectedProjects' });
        let inputProjects = makeSVG('g', { class: 'inputProjects' });
        let standAloneProjects = makeSVG('g', { class: 'standAloneProjects' });
        let projectFolders = makeSVG('g', { class: 'projectFolders' });

        svg.find('g[class=graph]').append(projectFolders);
        svg.find('g[class=graph]').append(connectedProjects);
        $(connectedProjects).append(inputProjects);
        svg.find('g[class=graph]').append(standAloneProjects);

        svg.find('g[data-type]').each(function (index, boxElement) {
            let node = FlowGraph.node($(boxElement).data("id"));
            // if its a draft dataset, move it to another elt
            if (node.nodeType == "PROJECT_FOLDER") {
                projectFolders.appendChild(boxElement);
            } else if (!node.predecessors.length && !node.successors.length) {
                standAloneProjects.appendChild(boxElement);
            } else if (!node.predecessors.length) {
                inputProjects.appendChild(boxElement);
            } else {
                connectedProjects.appendChild(boxElement);
            }
        });

        // Relayout
        let minProjectsPerRow = 3;
        let maxProjecsPerRow = 10;

        let projectsPerRows = Math.min(Math.max(minProjectsPerRow, Math.floor(Math.sqrt(standAloneProjects.childNodes.length))), maxProjecsPerRow);
        let cellMargin = 20
        let cellWidth = 150 + cellMargin;
        let cellHeight = 100 + cellMargin;
        let pfCellHeight = 40 + cellMargin;
        let rowWidth = cellWidth * projectsPerRows;
        if (inputProjects.childNodes.length) {
            cellWidth = inputProjects.childNodes[0].getBBox().width + 50;
            cellHeight = inputProjects.childNodes[0].getBBox().height + cellMargin;
            projectsPerRows = Math.min(Math.max(minProjectsPerRow, Math.floor(connectedProjects.getBBox().width / cellWidth)), maxProjecsPerRow);
        }
        if (projectFolders.childNodes.length) {
            pfCellHeight = projectFolders.childNodes[0].getBBox().height + cellMargin;
        }
        for(let index = 0; index < standAloneProjects.childNodes.length; index++) {
            let tr = (index % projectsPerRows) * cellWidth +' '+ Math.floor(index / projectsPerRows) * cellHeight;
            $(standAloneProjects).children().eq(index).find('g').first()
                .attr('transform', 'translate('+ tr +')');
        }
        for (let index = 0; index < projectFolders.childNodes.length; index++) {
            let tr = (index % projectsPerRows) * cellWidth + ' ' + Math.floor(index / projectsPerRows) * pfCellHeight;
            $(projectFolders).children().eq(index).find('g').first()
                .attr('transform', 'translate(' + tr + ')');
        }
        //  move standAloneProjects out of the way
        let connectedProjectsBB = connectedProjects.getBBox();
        let standAloneProjectsBB = standAloneProjects.getBBox();
        let sapTranslateX = connectedProjectsBB.x;
        let sapTranslateY = connectedProjectsBB.y + connectedProjectsBB.height + 100;
        standAloneProjects.setAttribute('transform', 'translate(' + sapTranslateX + ' ' + sapTranslateY + ')');
        // move projectFolders out of the way (upside)
        let projectFoldersBB = projectFolders.getBBox();
        let pfTranslateX = connectedProjectsBB.x;
        let pfTranslateY = connectedProjectsBB.y - (projectFoldersBB.height + 100);
        projectFolders.setAttribute('transform', 'translate(' + pfTranslateX + ' ' + pfTranslateY + ')');
    };
});


app.service('InterProjectGraphStyling', function($filter, ImageUrl, FlowGraph, CachedAPICalls, LoggerProvider, $sanitize) {

    const SIZE = 100;

    const logger = LoggerProvider.getLogger('projectsGraph');

    const formatters = {
        'PROJECT_FOLDER': restyleNodeForProjectFolder,
        'PROJECT': restyleNodeForProject,
        'BUNDLE_EO': restyleNodeForExposedObject,
    };
    let flowIconset;
    CachedAPICalls.flowIcons.success(function(data) {
        flowIconset = data;
    });

    this.restyleGraph = function(svg, graph) {
        svg.find('title').remove();
        svg.find('g[data-type]').each(function (index, g) {
            try {
                restyleNode(g);
            } catch (e) {
                logger.error("Failed to restyle flow node: ", e);
            }
        });
    };

    function restyleNode(g) {
        const nodeType = $(g).attr('data-type');
        if (formatters[nodeType]) {
            formatters[nodeType](g);
        }
    };

    function createExposedObjectSvg(nodeIcons, index, x, y, d) {
        const g = makeSVG('g', {
            class: nodeIcons[index].type,
            transform: 'translate(' + x + ' ' + y + ') scale(' + d/SIZE +',' + d/SIZE +')'
        });
        nodeIcons[index].elt[0].forEach(function(x){
            g.appendChild(x);
        });
        addCountToExposedObjectSvg(g, nodeIcons, index, x, y, d)
        return g
    }

    function addCountToExposedObjectSvg(g, nodeIcons, index, x, y, d) {
        const r = SIZE / 5;
        const cx = SIZE/2 + SIZE/(2 * Math.sqrt(2));
        const cy = SIZE/2 + SIZE/(2 * Math.sqrt(2));

        const circle = makeSVG('circle', {
            r: r,
            cx: cx,
            cy: cy,
            class: 'count-circle'
        });

        const text = makeSVG('text', {
            x: cx,
            y: cy,
            class: "count-text"
        });
        text.textContent = nodeIcons[index].nbElements;

        g.appendChild(circle);
        g.appendChild(text);
    }

    // several exposed objects (of different type) will result in one nodes containing several icons
    function drawExposedObjectNodeIcons(newG, nodeIcons, coords) {
        switch (nodeIcons.length) {
            case 1: {
                const g0 = createExposedObjectSvg(nodeIcons, 0, 1, 1, coords.width - 2);
                newG.appendChild(g0);
                break;
            }
            case 2: {
                const diameter = (coords.width - 2)/2;

                const x0 = 1;
                const y0 = 1 + coords.height/4;
                const g0 = createExposedObjectSvg(nodeIcons, 0, x0, y0, diameter);
                newG.appendChild(g0);

                const x1 = 1 + coords.width/2;
                const y1 = 1 + coords.height/4;
                const g1 = createExposedObjectSvg(nodeIcons, 1, x1, y1, diameter);
                newG.appendChild(g1);

                break;
            }
            case 3: {
                const diameter = (coords.width - 2)/2;

                const x0 = 1;
                const y0 = 1 + coords.height/4;
                const g0 = createExposedObjectSvg(nodeIcons, 0, x0, y0, diameter);
                newG.appendChild(g0);

                const x1 = 1 + coords.width/2;
                const y1 = 1;
                const g1 = createExposedObjectSvg(nodeIcons, 1, x1, y1, diameter);
                newG.appendChild(g1);

                const x2 = 1 + coords.width/2;
                const y2 = 1 + coords.height/2;
                const g2 = createExposedObjectSvg(nodeIcons, 2, x2, y2, diameter);
                newG.appendChild(g2);

                break;
            }
            case 4: {
                const diameter = (coords.width - 2)/2;

                const x0 = 1;
                const y0 = 1;
                const g0 = createExposedObjectSvg(nodeIcons, 0, x0, y0, diameter);
                newG.appendChild(g0);

                const x1 = 1;
                const y1 = 1 + coords.height/2;;
                const g1 = createExposedObjectSvg(nodeIcons, 1, x1, y1, diameter);
                newG.appendChild(g1);

                const x2 = 1 + coords.width/2;
                const y2 = 1;
                const g2 = createExposedObjectSvg(nodeIcons, 2, x2, y2, diameter);
                newG.appendChild(g2);

                const x3 = 1 + coords.width/2;
                const y3 = 1 + coords.height/2;
                const g3 = createExposedObjectSvg(nodeIcons, 3, x3, y3, diameter);
                newG.appendChild(g3);

                break;
            }
            case 5: {
                const diameter = (coords.width - 2)/3;

                const x0 = 1 + coords.width/3;
                const y0 = 1 ;
                const g0 = createExposedObjectSvg(nodeIcons, 0, x0, y0, diameter);
                newG.appendChild(g0);

                const x1 = 1;
                const y1 = 1 + coords.height/3;
                const g1 = createExposedObjectSvg(nodeIcons, 1, x1, y1, diameter);
                newG.appendChild(g1);

                const x2 = 1 + coords.width/3;
                const y2 = 1 + coords.height/3;
                const g2 = createExposedObjectSvg(nodeIcons, 2, x2, y2, diameter);
                newG.appendChild(g2);

                const x3 = 1 + coords.width * 2/3;
                const y3 = 1 + coords.height/3;
                const g3 = createExposedObjectSvg(nodeIcons, 3, x3, y3, diameter);
                newG.appendChild(g3);

                const x4 = 1 + coords.width/3;
                const y4 = 1 + coords.height * 2/3;
                const g4 = createExposedObjectSvg(nodeIcons, 4, x4, y4, diameter);
                newG.appendChild(g4);
            }
        }
    }

    function restyleNodeForProjectFolder(g) {
        const nodeId = $(g).attr('data-id');
        const projectFolder = FlowGraph.node(nodeId);
        const dotPolygon = $(g).find('polygon');

        //replacing polygon by g of same size
        const coords = polygonToRectData(dotPolygon);
        const newG = makeSVG('g', {class: 'newG', transform: 'translate(' + coords.x + ' ' + coords.y + ')'});
        $(dotPolygon).replaceWith(newG);
        $(g).find("text").remove();

        // fill
        newG.appendChild(makeSVG('rect', {
            x: 0,
            y: 0,
            width: coords.width,
            height: coords.height,
            class: 'fill'
        }));

        // html-content
        newG.appendChild(makeForeignObject(
            {
                x: 0,
                y: 0,
                width: coords.width,
                height: coords.height,
                class: 'project-folder-meta nodelabel-wrapper'
            },
            $(
                '<div>' +
                    '<p class="single-line"><i class="icon-folder-close"></i>' + $sanitize(projectFolder.description.replace(/([-_])/g, '$1\u200b')) + '</p>' +
                '</div>'
            )
        ));
    }

    function restyleNodeForProject(g) {
        const nodeId = $(g).attr('data-id');
        const project = FlowGraph.node(nodeId);
        const dotPolygon = $(g).find('polygon');

        //replacing polygon by g of same size
        const coords = polygonToRectData(dotPolygon);
        const newG = makeSVG('g', {class: 'newG',
            transform: 'translate(' + coords.x + ' ' + coords.y + ')'
        });
        if (project.isArchived) {
            d3.select(newG).classed("archived", true);
        }
        if (project.isForbidden) {
            d3.select(newG).classed("forbidden", true);
        }
        if (project.isNotInFolder) {
            d3.select(newG).classed("not-in-folder", true);
        }
        $(dotPolygon).replaceWith(newG);
        $(g).find("text").remove();

        //fill
        newG.appendChild(makeSVG('rect', {
            x: 0,
            y: 0,
            width: coords.width,
            height: coords.height,
            class: 'fill'
        }));

        // html-content
        newG.appendChild(makeForeignObject(
            {
                x: 0,
                y: 0,
                width: coords.width,
                height: coords.height,
                class: 'project-meta nodelabel-wrapper'
            },
            $(
                '<div>' +
                    '<i class="img-area">' + (project.isForbidden ? '' : ('<img src="' + ImageUrl(project.name, project.projectKey, project.projectKey, "PROJECT", project.objectImgHash, "80x200", project.imgColor, project.imgPattern, project.showInitials) + '" />')) + '</i>' +
                    '<p>' + $sanitize(project.description.replace(/([-_])/g, '$1\u200b')) + '</p>' +
                '</div>'
            )
        ));

        if (project.projectAppType === 'APP_TEMPLATE') {
            const appIconSize = 25;
            newG.appendChild(makeForeignObject(
                {
                    x: 0,
                    y: coords.height - appIconSize,
                    width: appIconSize,
                    height: appIconSize,
                    class: 'project-meta'
                },
                $(`
                    <div class="app-template-overlay app-template-overlay--graph" title="${project.isAppAsRecipe ? 'Application-as-recipe' : 'Visual application'} template">
                        <i class="${project.isAppAsRecipe ? 'icon-dku-application-as-recipe' : 'icon-project-app'}"></i>
                    </div>
                `)
            ));
        }

        // forbidden-project (we can still see it because we can read exposed object from it)
        if (project.isForbidden) {
            newG.appendChild(makeForeignObject({
                x: 113,
                y: 64,
                width: 30,
                height: 30,
                class: 'forbidden-icon'
            }, $('<div><i class="icon-lock" /></div>')));

        }

        // forbidden-project (we can still see it because we can read exposed object from it)
        if (project.isNotInFolder) {
            newG.appendChild(makeForeignObject({
                x: 35,
                y: 63,
                width: 30,
                height: 30,
                class: 'not-in-folder-icon'
            }, $('<div><span class="icon-stack"><i class="icon-folder-close"></i><i class="icon-ban-circle icon-stack-base"></i></span></div>')));

        }
    }

    function restyleNodeForExposedObject(g) {
        const icons = [];
        function addIcon (type, nbElements) {
            const icon = {};
            const iconText = flowIconset.icons[type];
            let iconElt = d3.select($.parseXML(iconText)).select("svg").selectAll("circle, path, rect");
            icon.elt = iconElt;
            icon.type = type;
            icon.nbElements = nbElements;
            icons.push(icon);
        }

        function addIcons(bundle) {
            if (bundle.exposedDatasets.length > 0) {
                addIcon("eo_datasets", bundle.exposedDatasets.length);
            }
            if (bundle.exposedFolders.length > 0) {
                addIcon("eo_folders", bundle.exposedFolders.length);
            }
            if (bundle.exposedModels.length > 0) {
                addIcon("eo_models", bundle.exposedModels.length);
            }
            if (bundle.exposedNotebooks.length > 0) {
                addIcon("eo_notebooks", bundle.exposedNotebooks.length);
            }
            if (bundle.exposedWebApps.length > 0) {
                addIcon("eo_webapps", bundle.exposedWebApps.length);
            }
            if (bundle.exposedReports.length > 0) {
                addIcon("eo_reports", bundle.exposedReports.length);
            }
            if (bundle.errorMessages.length > 0) {
                addIcon("error", bundle.errorMessages.length);
            }
        }

        const nodeId = $(g).attr('data-id');
        const bundle = FlowGraph.node(nodeId);

        const dotEllipse = $(g).find("ellipse");

        const coords = circleToRectData(dotEllipse);
        const newG = makeSVG('g', {class: 'newG', transform: `translate(${coords.x} ${coords.y})` });
        d3.select(newG).classed("bzicon", true);

        addIcons(bundle);
        if (icons.length == 0) {
            throw new Error("No icons for type", bundle);
        }
        drawExposedObjectNodeIcons(newG, icons, coords);

        try {
            $(dotEllipse).replaceWith(newG);
            // Invisible rect to capture mouse events, else
            // the holes in the icon don't capture the mouse
            newG.appendChild(makeSVG('rect', {
                x: 0,
                y: 0,
                width: coords.width,
                height: coords.height,
                opacity: 0
            }));
        } catch (e) {
        }

        const text = $(g).find('text:not(.count-text)');
        text.remove();
    }
});


app.service('FlowGraphFiltering', function(TimingService) {

    this.filterGraph = TimingService.wrapInTimePrinter("FlowGraphFiltering::filterGraph", function(svg, filter) {

        let d3node = d3.select(svg[0]);
        filter.keptNodes && d3node.selectAll('.node').classed('filter-remove', true).classed('filter-keep', false).classed('no-animation',true);
        filter.keptEdges && d3node.selectAll('.edge').classed('filter-remove', true).classed('filter-keep', false).classed('no-animation',true);

		let nodeIdMap = {};
		let nodeToMap = {};
        if (filter.keptNodes || filter.keptEdges) {
			// Build a simple  element-map on-the-fly to avoid having repeated calls of the form: svg.find(' [data-id="' + nodeId + '"]')[0];
			// This is a major performance improvement on larger flows

			svg.find('*').each(function (_, elt) {
				if (filter.keptNodes) {
					const nodeId = $(elt).attr('data-id');
					if (nodeId) nodeIdMap[nodeId] = elt;
				}
				if (filter.keptEdges) {
					const nodeTo = $(elt).attr('data-to');
					if (nodeTo) {
						if (nodeToMap[nodeTo] == undefined) nodeToMap[nodeTo] = [];
						nodeToMap[nodeTo].push(elt);
					}
				}
			});
		}

		filter.keptNodes && $.each(filter.keptNodes, function (idx, nodeId) {
			let elt = nodeIdMap[nodeId];
            if (elt == null) {
                // maybe a saved model
                const savedmodel_nodeId = 'savedmodel' + nodeId.substring('dataset'.length);
                elt = nodeIdMap[nodeId];
            }
            if (elt == null) {
                // maybe a model evaluation store
                const modelevaluationstore_nodeId = 'modelevaluationstore' + nodeId.substring('dataset'.length);
                elt = nodeIdMap[nodeId];
            }
			if (elt == null) {
				// or managed folder
				const managedfolder_nodeId = 'managedfolder' + nodeId.substring('dataset'.length);
				elt = nodeIdMap[nodeId];
			}
			if (elt == null) {
				return;
			}
			d3.select(elt).classed('filter-remove', false).classed('filter-keep', true);
		});

		$.each(filter.keptEdges, function (idx, toNodeId) {

			if (nodeToMap[toNodeId]) nodeToMap[toNodeId].forEach(function (elt) {
				d3.select(elt).classed('filter-remove', false).classed('filter-keep', true);
			});
            const savedmodel_nodeId = 'savedmodel' + toNodeId.substring('dataset'.length);
            if (nodeToMap[savedmodel_nodeId]) nodeToMap[savedmodel_nodeId].forEach(function (elt) {
                d3.select(elt).classed('filter-remove', false).classed('filter-keep', true);
            });
            const modelevaluationstore_nodeId = 'modelevaluationstore' + toNodeId.substring('dataset'.length);
            if (nodeToMap[modelevaluationstore_nodeId]) nodeToMap[modelevaluationstore_nodeId].forEach(function (elt) {
                d3.select(elt).classed('filter-remove', false).classed('filter-keep', true);
            });
			const managedfolder_nodeId = 'managedfolder' + toNodeId.substring('dataset'.length);
			if (nodeToMap[managedfolder_nodeId]) nodeToMap[managedfolder_nodeId].forEach(function (elt) {
				d3.select(elt).classed('filter-remove', false).classed('filter-keep', true);
			});
		});
        if (filter.removeFadedElements) {
            svg.find('.filter-remove').remove();
        }
        d3node.selectAll('.node').classed('no-animation',false);
        d3node.selectAll('.edge').classed('no-animation',false);
    });

    //TODO @flow move to another service
    this.getBBoxFromSelector = function (globalSvg, selector) {
        const svgs = $(selector).closest('svg'); // Retrieve correct svg (Mostly in case of zones)
        let gTopLeft, gBottomRight;
        svgs.each(function() {
            const svg = $(this);
            let topLeft, bottomRight;
            function addItemToBBox(refBBox) {
                return function() {
                    let bbox = this.getBBox();
                    if (refBBox && svg.is(globalSvg)) {
                        // "draftDatasets" (unconnected objects) have been translated,
                        // We need to compensate for that (Only when no zones are present)
                        bbox = {
                            x: bbox.x + refBBox.x,
                            y: bbox.y + refBBox.y,
                            width: bbox.width,
                            height: bbox.height,
                        };
                    }

                    if (topLeft === undefined) {
                        topLeft = svg[0].createSVGPoint();
                        topLeft.x = bbox.x;
                        topLeft.y = bbox.y;

                        bottomRight = svg[0].createSVGPoint();
                        bottomRight.x = bbox.x + bbox.width;
                        bottomRight.y = bbox.y + bbox.height;
                    } else {
                        topLeft.x = Math.min(topLeft.x, bbox.x);
                        topLeft.y = Math.min(topLeft.y, bbox.y);

                        bottomRight.x = Math.max(bottomRight.x, bbox.x + bbox.width);
                        bottomRight.y = Math.max(bottomRight.y, bbox.y + bbox.height);
                    }
                }
            }
            const graphBBox = svg.find('g.graph')[0].getBBox();
            const isZone = $(selector).parentsUntil(svg, '.usedDatasets').length === 0 && $(selector).parentsUntil(svg, '.draftDatasets').length === 0;
            const matrix = isZone ? svg[0].getTransformToElement(globalSvg[0]) : $('.usedDatasets', svg)[0].getTransformToElement(globalSvg[0]);

            if (isZone) {
                svg.find(selector).each(addItemToBBox());
            } else {
                $('.usedDatasets', svg).find(selector).each(addItemToBBox());
                $('.draftDatasets', svg).find(selector).each(addItemToBBox(graphBBox));
            }

            if (topLeft === undefined) {
                //console.info("Cannot compute bounding box around empty set of items");
                return undefined;
            }

            topLeft = topLeft.matrixTransform(matrix);
            bottomRight = bottomRight.matrixTransform(matrix);

            if (gTopLeft === undefined) {
                gTopLeft = { x: topLeft.x, y: topLeft.y };
                gBottomRight = { x: bottomRight.x, y: bottomRight.y };
            } else {
                gTopLeft.x = Math.min(gTopLeft.x, topLeft.x);
                gTopLeft.y = Math.min(gTopLeft.y, topLeft.y);

                gBottomRight.x = Math.max(gBottomRight.x, bottomRight.x);
                gBottomRight.y = Math.max(gBottomRight.y, bottomRight.y);
            }
        });

        if (gTopLeft === undefined) {
            return undefined;
        }

        return {
            x: gTopLeft.x,
            y: gTopLeft.y,
            width: gBottomRight.x - gTopLeft.x,
            height: gBottomRight.y - gTopLeft.y
        };
    };

    this.fadeOut = function(svg, filter) {
        // Fade out nodes that need to
        if (filter && filter.doFading) {
            let d3node = d3.select(svg[0]);
            d3node.selectAll('.node').classed('filter-faded', true);
            d3node.selectAll('.edge').classed('filter-faded', true);

            $.each(filter.nonFadedNodes, function(idx, nodeId) {
                let elt = svg.find(' [data-id="' + nodeId + '"]')[0];
                if (elt == null) {
                    // maybe a saved model
                    let savedmodel_nodeId = 'savedmodel' + nodeId.substring('dataset'.length);
                    elt = svg.find(' [data-id="' + savedmodel_nodeId + '"]')[0];
                    if (elt == null) {
                        // maybe a model evaluation store
                        let modelevaluationstore_nodeId = 'modelevaluationstore' + nodeId.substring('dataset'.length);
                        elt = svg.find(' [data-id="' + modelevaluationstore_nodeId + '"]')[0];
                        if (elt == null) {
                            // or managed folder
                            let managedfolder_nodeId = 'managedfolder' + nodeId.substring('dataset'.length);
                            elt = svg.find(' [data-id="' + managedfolder_nodeId + '"]')[0];
                            if (elt == null) {
                                return;
                            }
                        }
                    }
                }
                d3.select(elt).classed('filter-faded', false);
            });
            $.each(filter.nonFadedEdges, function(idx, toNodeId) {
                svg.find(' [data-to="' + toNodeId + '"]').each(function () {
                    d3.select(this).classed('filter-faded', false);
                });
                let savedmodel_nodeId = 'savedmodel' + toNodeId.substring('dataset'.length);
                svg.find(' [data-to="' + savedmodel_nodeId + '"]').each(function () {
                    d3.select(this).classed('filter-faded', false);
                });
                let modelevaluationstore_nodeId = 'modelevaluationstore' + toNodeId.substring('dataset'.length);
                svg.find(' [data-to="' + modelevaluationstore_nodeId + '"]').each(function () {
                    d3.select(this).classed('filter-faded', false);
                });
                let managedfolder_nodeId = 'managedfolder' + toNodeId.substring('dataset'.length);
                svg.find(' [data-to="' + managedfolder_nodeId + '"]').each(function () {
                    d3.select(this).classed('filter-faded', false);
                });
            });
        }
    };
});


function polygonToRectData(polygon) { // polygon is an svg element
    const points = $(polygon).attr('points').split(' ');
    // points = [top right, top left, bottom left, bottom right, top right]
    return {
        x: parseFloat(points[1].split(',')[0]),
        y: parseFloat(points[1].split(',')[1]),
        width: parseFloat(points[0].split(',')[0], 10) - parseFloat(points[1].split(',')[0], 10),
        height: parseFloat(points[2].split(',')[1], 10) - parseFloat(points[1].split(',')[1], 10)
    };
}

function circleToRectData(ellipse) {// ellipse is an svg element
    const el = $(ellipse);
    return {
        x: el.attr('cx') - el.attr("rx"),
        y: el.attr('cy') - el.attr("ry"),
        width: el.attr('rx') * 2,
        height: el.attr('ry') * 2
    };
}

function makeForeignObject(attrs, jq) {
    const el = makeSVG('foreignObject', attrs)
    $(el).append(jq);
    return el;
}

})();
